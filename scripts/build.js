#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Check if a file needs to be updated by comparing modification times
 * @param {string} srcPath - Source file path
 * @param {string} destPath - Destination file path
 * @returns {Promise<boolean>} True if file needs to be updated
 */
async function needsUpdate(srcPath, destPath) {
  try {
    const [srcStats, destStats] = await Promise.all([fs.stat(srcPath), fs.stat(destPath)]);
    return srcStats.mtime > destStats.mtime;
  } catch {
    // If destination doesn't exist, we need to update
    return true;
  }
}

/**
 * Generate version.ts file with caching
 * @param {object} pkg - Package.json content
 * @param {string} versionPath - Path to version.ts file
 */
async function generateVersionFile(pkg, versionPath) {
  const content = `// Auto-generated by build script
export const VERSION = '${pkg.version}';
export const PACKAGE_NAME = '${pkg.name}';
export const SERVER_NAME = '${pkg.name.split('-').slice(-2).join('-')}';
`;

  // Check if version.ts needs to be regenerated
  const packageJsonPath = path.join(__dirname, '..', 'package.json');
  const shouldUpdate = await needsUpdate(packageJsonPath, versionPath);

  if (shouldUpdate) {
    await fs.writeFile(versionPath, content);
    console.log('Generated version.ts with package values');
  } else {
    console.log('version.ts is up to date');
  }
}

/**
 * Copy resources with parallel processing and caching
 * @param {string} resourcesSrcDir - Source directory path
 * @param {string} resourcesBuildDir - Destination directory path
 */
async function copyResources(resourcesSrcDir, resourcesBuildDir) {
  try {
    // Ensure destination directory exists
    await fs.mkdir(resourcesBuildDir, { recursive: true });

    const files = await fs.readdir(resourcesSrcDir);

    // Process files in parallel with caching
    const copyPromises = files.map(async (file) => {
      const srcPath = path.join(resourcesSrcDir, file);
      const destPath = path.join(resourcesBuildDir, file);

      const shouldCopy = await needsUpdate(srcPath, destPath);

      if (shouldCopy) {
        await fs.copyFile(srcPath, destPath);
        return { file, copied: true };
      }
      return { file, copied: false };
    });

    const results = await Promise.all(copyPromises);
    const copiedFiles = results.filter((result) => result.copied);

    if (copiedFiles.length > 0) {
      console.log(`Copied ${copiedFiles.length} resources to build directory`);
    } else {
      console.log('All resources are up to date');
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('Error copying resources:', errorMessage);
    throw error;
  }
}

/**
 * Main build function that generates version.ts and copies resources
 * Reads package.json to extract version and name information
 * Copies markdown resources from src/resources to build/resources
 * Optimized with parallel operations and caching
 */
async function main() {
  const startTime = performance.now();

  // Read package.json
  const pkg = JSON.parse(await fs.readFile(path.join(__dirname, '..', 'package.json'), 'utf8'));

  const versionPath = path.join(__dirname, '..', 'src', 'version.ts');
  const resourcesSrcDir = path.join(__dirname, '..', 'src', 'resources');
  const resourcesBuildDir = path.join(__dirname, '..', 'build', 'resources');

  // Run version generation and resource copying in parallel
  await Promise.all([generateVersionFile(pkg, versionPath), copyResources(resourcesSrcDir, resourcesBuildDir)]);

  const endTime = performance.now();
  console.log(`Build completed in ${Math.round(endTime - startTime)}ms`);
}

main().catch(console.error);
